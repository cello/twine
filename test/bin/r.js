/**
 * @license r.js Copyright (c) 2010, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */

/*jslint nomen: false */
/*global require: true, process: false, global: false, logger: false, commonJs: false */
"use strict";

/*
 This file is an adapter file to allow RequireJS to run in node.
 If you are in the directory that contains the JS file you want node to
 run, then issue this command (assuming you want to run index.js):
 > node path/to/r.js index.js
*/

(function () {
    var fs = require("fs"),
        sys = require("sys"),
        path = require("path"),
        cwd = process.cwd(),
        appFilePath = process.argv[2],
        paths = require.paths,
        isDebug = false,
        appDir, content;

    if (appFilePath === "debug") {
        isDebug = true;
        appFilePath = process.argv[3];
    }

    //Make sure path to app file is absolute.
    if (appFilePath.charAt(0) !== "/") {
        appFilePath = [cwd, appFilePath].join("/");
    }

    //Now get app directory.
    appDir = appFilePath.split("/");
    appDir.pop();
    if (appDir.length) {
        appDir = appDir.join("/");
    } else {
        appDir = '.';
    }

    //Create some temporary globals that will be removed by the injected file.
    global.__requireIsDebug = isDebug;
    global.__requireLog = sys.puts;
    global.__requireReadFile = function (path) {
        return fs.readFileSync(path) + '';
    };
    global.__requireFileExists = function (fileName) {
        return path.existsSync(fileName);
    };
    global.__requirePaths = paths;

    //dist.sh will inject the modified requireAdapter content as a string.
    process.compile("/**\n * @license RequireJS requireAdapter Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint nomen: false, plusplus: false, regexp: false */\n/*global require: false, process: false, global: false,\n         console: false, logger: false, commonJs: false */\n\n\"use strict\";\n\n/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 0.22.0 Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint plusplus: false */\n/*global window: false, navigator: false, document: false, importScripts: false,\n  jQuery: false, clearInterval: false, setInterval: false, self: false,\n  setTimeout: false */\n\"use strict\";\n\nvar require, define;\n(function () {\n    //Change this version number for each release.\n    var version = \"0.22.0\",\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /require\\([\"\']([^\'\"\\s]+)[\"\']\\)/g,\n        currDirRegExp = /^\\.\\//,\n        ostring = Object.prototype.toString,\n        ap = Array.prototype,\n        aps = ap.slice,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== \"undefined\" && navigator && document),\n        isWebWorker = !isBrowser && typeof importScripts !== \"undefined\",\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is \"loading\", \"loaded\", execution,\n        // then \"complete\". The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === \'PLAYSTATION 3\' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = \"_\",\n        reqWaitIdPrefix = \"_r@@\",\n        empty = {},\n        contexts = {},\n        globalDefQueue = [],\n        interactiveScript = null,\n        isDone = false,\n        useInteractive = false,\n        //Default plugins that have remapped names, if no mapping\n        //already exists.\n        requirePlugins = {\n            \"text\": \"require/text\",\n            \"i18n\": \"require/i18n\",\n            \"order\": \"require/order\"\n        },\n        req, cfg = {}, currentlyAddingScript, s, head, baseElement, scripts, script,\n        rePkg, src, m, dataMain, i, scrollIntervalId, setReadyState, ctx;\n\n    function isFunction(it) {\n        return ostring.call(it) === \"[object Function]\";\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === \"[object Array]\";\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     * This is not robust in IE for transferring methods that match\n     * Object.prototype names, but the uses of mixin here seem unlikely to\n     * trigger a problem related to that.\n     */\n    function mixin(target, source, force) {\n        for (var prop in source) {\n            if (!(prop in empty) && (!(prop in target) || force)) {\n                target[prop] = source[prop];\n            }\n        }\n        return req;\n    }\n\n    /**\n     * Used to set up package paths from a packagePaths or packages config object.\n     * @param {Object} packages the object to store the new package config\n     * @param {Array} currentPackages an array of packages to configure\n     * @param {String} [dir] a prefix dir to use.\n     */\n    function configurePackageDir(packages, currentPackages, dir) {\n        var i, location, pkgObj;\n        for (i = 0; (pkgObj = currentPackages[i]); i++) {\n            pkgObj = typeof pkgObj === \"string\" ? { name: pkgObj } : pkgObj;\n            location = pkgObj.location;\n\n            //Add dir to the path, but avoid paths that start with a slash\n            //or have a colon (indicates a protocol)\n            if (dir && (!location || (location.indexOf(\"/\") !== 0 && location.indexOf(\":\") === -1))) {\n                pkgObj.location = dir + \"/\" + (pkgObj.location || pkgObj.name);\n            }\n\n            //Normalize package paths.\n            pkgObj.location = pkgObj.location || pkgObj.name;\n            pkgObj.lib = pkgObj.lib || \"lib\";\n            //Remove leading dot in main, so main paths are normalized.\n            pkgObj.main = (pkgObj.main || \"lib/main\").replace(currDirRegExp, \'\');\n\n            packages[pkgObj.name] = pkgObj;\n        }\n    }\n\n    //Check for an existing version of require. If so, then exit out. Only allow\n    //one version of require to be active in a page. However, allow for a require\n    //config object, just exit quickly if require is an actual function.\n    if (typeof require !== \"undefined\") {\n        if (isFunction(require)) {\n            return;\n        } else {\n            //assume it is a config object.\n            cfg = require;\n        }\n    }\n\n    /**\n     * Creates a new context for use in require and define calls.\n     * Handle most of the heavy lifting. Do not want to use an object\n     * with prototype here to avoid using \"this\" in require, in case it\n     * needs to be used in more super secure envs that do not want this.\n     * Also there should not be that many contexts in the page. Usually just\n     * one for the default context, but could be extra for multiversion cases\n     * or if a package needs a special context for a dependency that conflicts\n     * with the standard context.\n     */\n    function newContext(contextName) {\n        var context, resume,\n            config = {\n                waitSeconds: 7,\n                baseUrl: s.baseUrl || \"./\",\n                paths: {},\n                packages: {}\n            },\n            defQueue = [],\n            specified = {\n                \"require\": true,\n                \"exports\": true,\n                \"module\": true\n            },\n            urlMap = {},\n            defined = {},\n            loaded = {},\n            waiting = {},\n            waitAry = [],\n            waitIdCounter = 0,\n            managerCallbacks = {},\n            plugins = {},\n            pluginsQueue = {},\n            normalizedWaiting = {};\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part;\n            for (i = 0; (part = ary[i]); i++) {\n                if (part === \".\") {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === \"..\") {\n                    if (i === 1 && (ary[2] === \'..\' || ary[0] === \'..\')) {\n                        //End of the line. Keep at least one non-dot\n                        //path segment at the front so it can be mapped\n                        //correctly to disk. Otherwise, there is likely\n                        //no path mapping for a path starting with \'..\'.\n                        //This can still fail, but catches the most reasonable\n                        //uses of ..\n                        break;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName) {\n            var pkgName, pkgConfig;\n\n            //Adjust any relative paths.\n            if (name.charAt(0) === \".\") {\n                //If have a base name, try to normalize against it,\n                //otherwise, assume it is a top-level require that will\n                //be relative to baseUrl in the end.\n                if (baseName) {\n                    if (config.packages[baseName]) {\n                        //If the baseName is a package name, then just treat it as one\n                        //name to concat the name with.\n                        baseName = [baseName];\n                    } else {\n                        //Convert baseName to array, and lop off the last part,\n                        //so that . matches that \"directory\" and not name of the baseName\'s\n                        //module. For instance, baseName of \"one/two/three\", maps to\n                        //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                        //this normalization.\n                        baseName = baseName.split(\"/\");\n                        baseName = baseName.slice(0, baseName.length - 1);\n                    }\n\n                    name = baseName.concat(name.split(\"/\"));\n                    trimDots(name);\n\n                    //Some use of packages may use a . path to reference the\n                    //\"main\" module name, so normalize for that.\n                    pkgConfig = config.packages[(pkgName = name[0])];\n                    name = name.join(\"/\");\n                    if (pkgConfig && name === pkgName + \'/\' + pkgConfig.main) {\n                        name = pkgName;\n                    }\n                }\n            }\n            return name;\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap) {\n            var index = name ? name.indexOf(\"!\") : -1,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                normalizedName, url, pluginModule;\n\n            if (index !== -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName);\n                //Allow simpler mappings for some plugins\n                prefix = requirePlugins[prefix] || prefix;\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    pluginModule = defined[prefix];\n                    if (pluginModule) {\n                        //Plugin is loaded, use its normalize method, otherwise,\n                        //normalize name as usual.\n                        if (pluginModule.normalize) {\n                            normalizedName = pluginModule.normalize(name, function (name) {\n                                return normalize(name, parentName);\n                            });\n                        } else {\n                            normalizedName = normalize(name, parentName);\n                        }\n                    } else {\n                        //Plugin is not loaded yet, so do not normalize\n                        //the name, wait for plugin to load to see if\n                        //it has a normalize method. To avoid possible\n                        //ambiguity with relative names loaded from another\n                        //plugin, use the parent\'s name as part of this name.\n                        normalizedName = \'__$p\' + parentName + \'@\' + name;\n                    }\n                } else {\n                    normalizedName = normalize(name, parentName);\n                }\n\n                url = urlMap[normalizedName];\n                if (!url) {\n                    //Calculate url for the module, if it has a name.\n                    if (req.toModuleUrl) {\n                        //Special logic required for a particular engine,\n                        //like Node.\n                        url = req.toModuleUrl(context, name, parentModuleMap);\n                    } else {\n                        url = context.nameToUrl(name, null, parentModuleMap);\n                    }\n\n                    //Store the URL mapping for later.\n                    urlMap[normalizedName] = url;\n                }\n            }\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                url: url,\n                originalName: originalName,\n                fullName: prefix ? prefix + \"!\" + normalizedName : normalizedName\n            };\n        }\n\n        /**\n         * Determine if priority loading is done. If so clear the priorityWait\n         */\n        function isPriorityDone() {\n            var priorityDone = true,\n                priorityWait = config.priorityWait,\n                priorityName, i;\n            if (priorityWait) {\n                for (i = 0; (priorityName = priorityWait[i]); i++) {\n                    if (!loaded[priorityName]) {\n                        priorityDone = false;\n                        break;\n                    }\n                }\n                if (priorityDone) {\n                    delete config.priorityWait;\n                }\n            }\n            return priorityDone;\n        }\n\n        /**\n         * Helper function that creates a setExports function for a \"module\"\n         * CommonJS dependency. Do this here to avoid creating a closure that\n         * is part of a loop.\n         */\n        function makeSetExports(moduleObj) {\n            return function (exports) {\n                moduleObj.exports = exports;\n            };\n        }\n\n        function makeContextModuleFunc(func, relModuleMap, enableBuildCallback) {\n            return function () {\n                //A version of a require function that passes a moduleName\n                //value for items that may need to\n                //look up paths relative to the moduleName\n                var args = [].concat(aps.call(arguments, 0)), lastArg;\n                if (enableBuildCallback &&\n                    isFunction((lastArg = args[args.length - 1]))) {\n                    lastArg.__requireJsBuild = true;\n                }\n                args.push(relModuleMap);\n                return func.apply(null, args);\n            };\n        }\n\n        /**\n         * Helper function that creates a require function object to give to\n         * modules that ask for it as a dependency. It needs to be specific\n         * per module because of the implication of path mappings that may\n         * need to be relative to the module name.\n         */\n        function makeRequire(relModuleMap, enableBuildCallback) {\n            var modRequire = makeContextModuleFunc(context.require, relModuleMap, enableBuildCallback);\n\n            mixin(modRequire, {\n                nameToUrl: makeContextModuleFunc(context.nameToUrl, relModuleMap),\n                toUrl: makeContextModuleFunc(context.toUrl, relModuleMap),\n                isDefined: makeContextModuleFunc(context.isDefined, relModuleMap),\n                ready: req.ready,\n                isBrowser: req.isBrowser\n            });\n            //Something used by node.\n            if (req.paths) {\n                modRequire.paths = req.paths;\n            }\n            return modRequire;\n        }\n\n        /**\n         * Used to update the normalized name for plugin-based dependencies\n         * after a plugin loads, since it can have its own normalization structure.\n         * @param {String} pluginName the normalized plugin module name.\n         */\n        function updateNormalizedNames(pluginName) {\n\n            var oldFullName, oldModuleMap, moduleMap, fullName, callbacks,\n                i, j, k, depArray,\n                maps = normalizedWaiting[pluginName];\n\n            if (maps) {\n                for (i = 0; (oldModuleMap = maps[i]); i++) {\n                    oldFullName = oldModuleMap.fullName;\n                    moduleMap = makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap);\n                    fullName = moduleMap.fullName;\n                    callbacks = managerCallbacks[oldFullName];\n\n                    if (fullName !== oldFullName) {\n                        //Update managerCallbacks to use the correct normalized name.\n                        managerCallbacks[fullName] = callbacks;\n                        delete managerCallbacks[oldFullName];\n\n                        //In each manager callback, update the normalized name in the depArray.\n                        for (j = 0; j < callbacks.length; j++) {\n                            depArray = callbacks[j].depArray;\n                            for (k = 0; k < depArray.length; k++) {\n                                if (depArray[k] === oldFullName) {\n                                    depArray[k] = fullName;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            delete normalizedWaiting[pluginName];\n        }\n\n        /*\n         * Queues a dependency for checking after the loader is out of a\n         * \"paused\" state, for example while a script file is being loaded\n         * in the browser, where it may have many modules defined in it.\n         *\n         * depName will be fully qualified, no relative . or .. path.\n         */\n        function queueDependency(dep) {\n            //Make sure to load any plugin and associate the dependency\n            //with that plugin.\n            var prefix = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the depName is already in transit\n            if (specified[fullName] || fullName in defined) {\n                return;\n            }\n\n            if (prefix && !plugins[prefix]) {\n                //Queue up loading of the dependency, track it\n                //via context.plugins. Mark it as a plugin so\n                //that the build system will know to treat it\n                //special.\n                plugins[prefix] = undefined;\n\n                //Remember this dep that needs to have normaliztion done\n                //after the plugin loads.\n                (normalizedWaiting[prefix] || (normalizedWaiting[prefix] = []))\n                    .push(dep);\n\n                //Register an action to do once the plugin loads, to update\n                //all managerCallbacks to use a properly normalized module\n                //name.\n                (managerCallbacks[prefix] ||\n                (managerCallbacks[prefix] = [])).push({\n                    onDep: function (name, value) {\n                        if (name === prefix) {\n                            updateNormalizedNames(prefix);\n                        }\n                    }\n                });\n\n                queueDependency(makeModuleMap(prefix));\n            }\n\n            context.paused.push(dep);\n        }\n\n        function execManager(manager) {\n            var i, ret, waitingCallbacks,\n                cb = manager.callback,\n                fullName = manager.fullName,\n                args = [],\n                ary = manager.depArray;\n\n            //Call the callback to define the module, if necessary.\n            if (cb && isFunction(cb)) {\n                //Pull out the defined dependencies and pass the ordered\n                //values to the callback.\n                if (ary) {\n                    for (i = 0; i < ary.length; i++) {\n                        args.push(manager.deps[ary[i]]);\n                    }\n                }\n\n                ret = req.execCb(fullName, manager.callback, args);\n\n                if (fullName) {\n                    //If using exports and the function did not return a value,\n                    //and the \"module\" object for this definition function did not\n                    //define an exported value, then use the exports object.\n                    if (manager.usingExports && ret === undefined && (!manager.cjsModule || !(\"exports\" in manager.cjsModule))) {\n                        ret = defined[fullName];\n                    } else {\n                        if (manager.cjsModule && \"exports\" in manager.cjsModule) {\n                            ret = defined[fullName] = manager.cjsModule.exports;\n                        } else {\n                            if (fullName in defined && !manager.usingExports) {\n                                return req.onError(new Error(fullName + \" has already been defined\"));\n                            }\n                            defined[fullName] = ret;\n                        }\n                    }\n                }\n            } else if (fullName) {\n                //May just be an object definition for the module. Only\n                //worry about defining if have a module name.\n                ret = defined[fullName] = cb;\n            }\n\n            if (fullName) {\n                //If anything was waiting for this module to be defined,\n                //notify them now.\n                waitingCallbacks = managerCallbacks[fullName];\n                if (waitingCallbacks) {\n                    for (i = 0; i < waitingCallbacks.length; i++) {\n                        waitingCallbacks[i].onDep(fullName, ret);\n                    }\n                    delete managerCallbacks[fullName];\n                }\n            }\n\n            //Clean up waiting.\n            if (waiting[manager.waitId]) {\n                delete waiting[manager.waitId];\n                manager.isDone = true;\n                context.waitCount -= 1;\n                if (context.waitCount === 0) {\n                    //Clear the wait array used for cycles.\n                    waitAry = [];\n                }\n            }\n\n            return undefined;\n        }\n\n        function main(inName, depArray, callback, relModuleMap) {\n            var moduleMap = makeModuleMap(inName, relModuleMap),\n                name = moduleMap.name,\n                fullName = moduleMap.fullName,\n                manager = {\n                    //Use a wait ID because some entries are anon\n                    //async require calls.\n                    waitId: name || reqWaitIdPrefix + (waitIdCounter++),\n                    depCount: 0,\n                    depMax: 0,\n                    prefix: moduleMap.prefix,\n                    name: name,\n                    fullName: fullName,\n                    deps: {},\n                    depArray: depArray,\n                    callback: callback,\n                    onDep: function (depName, value) {\n                        if (!(depName in manager.deps)) {\n                            manager.deps[depName] = value;\n                            manager.depCount += 1;\n                            if (manager.depCount === manager.depMax) {\n                                //All done, execute!\n                                execManager(manager);\n                            }\n                        }\n                    }\n                },\n                i, depArg, depName, cjsMod;\n\n            if (fullName) {\n                //If module already defined for context, or already loaded,\n                //then leave.\n                if (fullName in defined || loaded[fullName] === true) {\n                    return;\n                }\n\n                //Set specified/loaded here for modules that are also loaded\n                //as part of a layer, where onScriptLoad is not fired\n                //for those cases. Do this after the inline define and\n                //dependency tracing is done.\n                //Also check if auto-registry of jQuery needs to be skipped.\n                specified[fullName] = true;\n                loaded[fullName] = true;\n                context.jQueryDef = (fullName === \"jquery\");\n            }\n\n            //Add the dependencies to the deps field, and register for callbacks\n            //on the dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                depArg = depArray[i];\n                //There could be cases like in IE, where a trailing comma will\n                //introduce a null dependency, so only treat a real dependency\n                //value as a dependency.\n                if (depArg) {\n                    //Split the dependency name into plugin and name parts\n                    depArg = makeModuleMap(depArg, (name ? moduleMap : relModuleMap));\n                    depName = depArg.fullName;\n\n                    //Fix the name in depArray to be just the name, since\n                    //that is how it will be called back later.\n                    depArray[i] = depName;\n\n                    //Fast path CommonJS standard dependencies.\n                    if (depName === \"require\") {\n                        manager.deps[depName] = makeRequire(moduleMap);\n                    } else if (depName === \"exports\") {\n                        //CommonJS module spec 1.1\n                        manager.deps[depName] = defined[fullName] = {};\n                        manager.usingExports = true;\n                    } else if (depName === \"module\") {\n                        //CommonJS module spec 1.1\n                        manager.cjsModule = cjsMod = manager.deps[depName] = {\n                            id: name,\n                            uri: name ? context.nameToUrl(name, null, relModuleMap) : undefined\n                        };\n                        cjsMod.setExports = makeSetExports(cjsMod);\n                    } else if (depName in defined && !(depName in waiting)) {\n                        //Module already defined, no need to wait for it.\n                        manager.deps[depName] = defined[depName];\n                    } else {\n                        //A dynamic dependency.\n                        manager.depMax += 1;\n\n                        queueDependency(depArg);\n\n                        //Register to get notification when dependency loads.\n                        (managerCallbacks[depName] ||\n                        (managerCallbacks[depName] = [])).push(manager);\n                    }\n                }\n            }\n\n            //Do not bother tracking the manager if it is all done.\n            if (manager.depCount === manager.depMax) {\n                //All done, execute!\n                execManager(manager);\n            } else {\n                waiting[manager.waitId] = manager;\n                waitAry.push(manager);\n                context.waitCount += 1;\n            }\n        }\n\n        /**\n         * Convenience method to call main for a require.def call that was put on\n         * hold in the defQueue.\n         */\n        function callDefMain(args) {\n            main.apply(null, args);\n            //Mark the module loaded. Must do it here in addition\n            //to doing it in require.def in case a script does\n            //not call require.def\n            loaded[args[0]] = true;\n        }\n\n        /**\n         * As of jQuery 1.4.3, it supports a readyWait property that will hold off\n         * calling jQuery ready callbacks until all scripts are loaded. Be sure\n         * to track it if readyWait is available. Also, since jQuery 1.4.3 does\n         * not register as a module, need to do some global inference checking.\n         * Even if it does register as a module, not guaranteed to be the precise\n         * name of the global. If a jQuery is tracked for this context, then go\n         * ahead and register it as a module too, if not already in process.\n         */\n        function jQueryCheck(jqCandidate) {\n            if (!context.jQuery) {\n                var $ = jqCandidate || (typeof jQuery !== \"undefined\" ? jQuery : null);\n                if ($ && \"readyWait\" in $) {\n                    context.jQuery = $;\n\n                    //Manually create a \"jquery\" module entry if not one already\n                    //or in process.\n                    callDefMain([\"jquery\", [], function () {\n                        return jQuery;\n                    }]);\n\n                    //Increment jQuery readyWait if ncecessary.\n                    if (context.scriptCount) {\n                        $.readyWait += 1;\n                        context.jQueryIncremented = true;\n                    }\n                }\n            }\n        }\n\n        function forceExec(manager, traced) {\n            if (manager.isDone) {\n                return undefined;\n            }\n\n            var fullName = manager.fullName,\n                depArray = manager.depArray,\n                depName, i;\n            if (fullName) {\n                if (traced[fullName]) {\n                    return defined[fullName];\n                }\n\n                traced[fullName] = true;\n            }\n\n            //forceExec all of its dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                //Some array members may be null, like if a trailing comma\n                //IE, so do the explicit [i] access and check if it has a value.\n                depName = depArray[i];\n                if (depName) {\n                    if (!manager.deps[depName] && waiting[depName]) {\n                        manager.onDep(depName, forceExec(waiting[depName], traced));\n                    }\n                }\n            }\n\n            return fullName ? defined[fullName] : undefined;\n        }\n\n        /**\n         * Checks if all modules for a context are loaded, and if so, evaluates the\n         * new ones in right dependency order.\n         *\n         * @private\n         */\n        function checkLoaded() {\n            var waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = \"\", hasLoadedProp = false, stillLoading = false, prop,\n                err, manager;\n\n            //Determine if priority loading is done. If so clear the priority. If\n            //not, then do not check\n            if (config.priorityWait) {\n                if (isPriorityDone()) {\n                    //Call resume, since it could have\n                    //some waiting dependencies to trace.\n                    resume();\n                } else {\n                    return undefined;\n                }\n            }\n\n            //See if anything is still in flight.\n            for (prop in loaded) {\n                if (!(prop in empty)) {\n                    hasLoadedProp = true;\n                    if (!loaded[prop]) {\n                        if (expired) {\n                            noLoads += prop + \" \";\n                        } else {\n                            stillLoading = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //Check for exit conditions.\n            if (!hasLoadedProp && !context.waitCount) {\n                //If the loaded object had no items, then the rest of\n                //the work below does not need to be done.\n                return undefined;\n            }\n            if (expired && noLoads) {\n                //If wait time expired, throw error of unloaded modules.\n                err = new Error(\"require.js load timeout for modules: \" + noLoads);\n                err.requireType = \"timeout\";\n                err.requireModules = noLoads;\n                return req.onError(err);\n            }\n            if (stillLoading || context.scriptCount) {\n                //Something is still waiting to load. Wait for it.\n                if (isBrowser || isWebWorker) {\n                    setTimeout(checkLoaded, 50);\n                }\n                return undefined;\n            }\n\n            //If still have items in the waiting cue, but all modules have\n            //been loaded, then it means there are some circular dependencies\n            //that need to be broken.\n            //However, as a waiting thing is fired, then it can add items to\n            //the waiting cue, and those items should not be fired yet, so\n            //make sure to redo the checkLoaded call after breaking a single\n            //cycle, if nothing else loaded then this logic will pick it up\n            //again.\n            if (context.waitCount) {\n                //Cycle through the waitAry, and call items in sequence.\n                for (i = 0; (manager = waitAry[i]); i++) {\n                    forceExec(manager, {});\n                }\n\n                checkLoaded();\n                return undefined;\n            }\n\n            //Check for DOM ready, and nothing is waiting across contexts.\n            req.checkReadyState();\n\n            return undefined;\n        }\n\n        function callPlugin(pluginName, dep) {\n            var name = dep.name,\n                fullName = dep.fullName;\n\n            //Do not bother if plugin is already defined.\n            if (fullName in defined) {\n                return;\n            }\n\n            if (!plugins[pluginName]) {\n                plugins[pluginName] = defined[pluginName];\n            }\n\n            //Only set loaded to false for tracking if it has not already been set.\n            if (!loaded[fullName]) {\n                loaded[fullName] = false;\n            }\n\n            //Use parentName here since the plugin\'s name is not reliable,\n            //could be some weird string with no path that actually wants to\n            //reference the parentName\'s path.\n            plugins[pluginName].load(name, makeRequire(dep.parentMap, true), function (ret) {\n                //Allow the build process to register plugin-loaded dependencies.\n                if (require.onPluginLoad) {\n                    require.onPluginLoad(context, pluginName, name, ret);\n                }\n\n                execManager({\n                    prefix: dep.prefix,\n                    name: dep.name,\n                    fullName: dep.fullName,\n                    callback: ret\n                });\n                loaded[fullName] = true;\n            }, config);\n        }\n\n        function loadPaused(dep) {\n            //Renormalize dependency if its name was waiting on a plugin\n            //to load, which as since loaded.\n            if (dep.prefix && dep.name.indexOf(\'__$p\') === 0 && defined[dep.prefix]) {\n                dep = makeModuleMap(dep.originalName, dep.parentMap);\n            }\n\n            var pluginName = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the dependency has already been specified.\n            if (specified[fullName] || fullName in defined) {\n                return;\n            } else {\n                specified[fullName] = true;\n            }\n\n            if (pluginName) {\n                //If plugin not loaded, wait for it.\n                //set up callback list. if no list, then register\n                //managerCallback for that plugin.\n                if (defined[pluginName]) {\n                    callPlugin(pluginName, dep);\n                } else {\n                    if (!pluginsQueue[pluginName]) {\n                        pluginsQueue[pluginName] = [];\n                        (managerCallbacks[pluginName] ||\n                        (managerCallbacks[pluginName] = [])).push({\n                            onDep: function (name, value) {\n                                if (name === pluginName) {\n                                    var i, oldModuleMap, ary = pluginsQueue[pluginName];\n\n                                    //Now update all queued plugin actions.\n                                    for (i = 0; i < ary.length; i++) {\n                                        oldModuleMap = ary[i];\n                                        //Update the moduleMap since the\n                                        //module name may be normalized\n                                        //differently now.\n                                        callPlugin(pluginName,\n                                                   makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap));\n                                    }\n                                    delete pluginsQueue[pluginName];\n                                }\n                            }\n                        });\n                    }\n                    pluginsQueue[pluginName].push(dep);\n                }\n            } else {\n                req.load(context, fullName, dep.url);\n            }\n        }\n\n        /**\n         * Resumes tracing of dependencies and then checks if everything is loaded.\n         */\n        resume = function () {\n            var args, i, p;\n\n            if (context.scriptCount <= 0) {\n                //Synchronous envs will push the number below zero with the\n                //decrement above, be sure to set it back to zero for good measure.\n                //require() calls that also do not end up loading scripts could\n                //push the number negative too.\n                context.scriptCount = 0;\n            }\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return req.onError(new Error(\'Mismatched anonymous require.def modules\'));\n                } else {\n                    callDefMain(args);\n                }\n            }\n\n            //Skip the resume if current context is in priority wait.\n            if (config.priorityWait && !isPriorityDone()) {\n                return undefined;\n            }\n\n            while (context.paused.length) {\n                p = context.paused;\n                //Reset paused list\n                context.paused = [];\n\n                for (i = 0; (args = p[i]); i++) {\n                    loadPaused(args);\n                }\n                //Move the start time for timeout forward.\n                context.startTime = (new Date()).getTime();\n            }\n\n            checkLoaded();\n\n            return undefined;\n        };\n\n        //Define the context object. Many of these fields are on here\n        //just to make debugging easier.\n        context = {\n            contextName: contextName,\n            config: config,\n            defQueue: defQueue,\n            waiting: waiting,\n            waitCount: 0,\n            specified: specified,\n            loaded: loaded,\n            urlMap: urlMap,\n            scriptCount: 0,\n            urlFetched: {},\n            defined: defined,\n            paused: [],\n            plugins: plugins,\n            managerCallbacks: managerCallbacks,\n            makeModuleMap: makeModuleMap,\n            normalize: normalize,\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                var paths, packages, prop, packagePaths, requireWait;\n\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== \"/\") {\n                        cfg.baseUrl += \"/\";\n                    }\n                }\n\n                //Save off the paths and packages since they require special processing,\n                //they are additive.\n                paths = config.paths;\n                packages = config.packages;\n\n                //Mix in the config values, favoring the new values over\n                //existing ones in context.config.\n                mixin(config, cfg, true);\n\n                //Adjust paths if necessary.\n                if (cfg.paths) {\n                    for (prop in cfg.paths) {\n                        if (!(prop in empty)) {\n                            paths[prop] = cfg.paths[prop];\n                        }\n                    }\n                    config.paths = paths;\n                }\n\n                packagePaths = cfg.packagePaths;\n                if (packagePaths || cfg.packages) {\n                    //Convert packagePaths into a packages config.\n                    if (packagePaths) {\n                        for (prop in packagePaths) {\n                            if (!(prop in empty)) {\n                                configurePackageDir(packages, packagePaths[prop], prop);\n                            }\n                        }\n                    }\n\n                    //Adjust packages if necessary.\n                    if (cfg.packages) {\n                        configurePackageDir(packages, cfg.packages);\n                    }\n\n                    //Done with modifications, assing packages back to context config\n                    config.packages = packages;\n                }\n\n                //If priority loading is in effect, trigger the loads now\n                if (cfg.priority) {\n                    //Create a separate config property that can be\n                    //easily tested for config priority completion.\n                    //Do this instead of wiping out the config.priority\n                    //in case it needs to be inspected for debug purposes later.\n                    //Hold on to requireWait value, and reset it after done\n                    requireWait = context.requireWait;\n                    context.requireWait = false;\n                    context.require(cfg.priority);\n                    context.requireWait = requireWait;\n                    config.priorityWait = cfg.priority;\n                }\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n\n                //Set up ready callback, if asked. Useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.ready) {\n                    req.ready(cfg.ready);\n                }\n            },\n\n            isDefined: function (moduleName, relModuleMap) {\n                return makeModuleMap(moduleName, relModuleMap).fullName in defined;\n            },\n\n            require: function (deps, callback, relModuleMap) {\n                var moduleName, ret, moduleMap;\n                if (typeof deps === \"string\") {\n                    //Synchronous access to one module. If require.get is\n                    //available (as in the Node adapter), prefer that.\n                    //In this case deps is the moduleName and callback is\n                    //the relModuleMap\n                    if (req.get) {\n                        return req.get(context, deps, callback);\n                    }\n\n                    //Just return the module wanted. In this scenario, the\n                    //second arg (if passed) is just the relModuleMap.\n                    moduleName = deps;\n                    relModuleMap = callback;\n\n                    //Normalize module name, if it contains . or ..\n                    moduleMap = makeModuleMap(moduleName, relModuleMap);\n\n                    ret = defined[moduleMap.fullName];\n                    if (ret === undefined) {\n                        return req.onError(new Error(\"require: module name \'\" +\n                                    moduleMap.fullName +\n                                    \"\' has not been loaded yet for context: \" +\n                                    contextName));\n                    }\n                    return ret;\n                }\n\n                main(null, deps, callback, relModuleMap);\n\n                //If the require call does not trigger anything new to load,\n                //then resume the dependency processing.\n                if (!context.requireWait) {\n                    while (!context.scriptCount && context.paused.length) {\n                        resume();\n                    }\n                }\n                return undefined;\n            },\n\n            /**\n             * Internal method to transfer globalQueue items to this context\'s\n             * defQueue.\n             */\n            takeGlobalQueue: function () {\n                //Push all the globalDefQueue items into the context\'s defQueue\n                if (globalDefQueue.length) {\n                    //Array splice in the values since the context code has a\n                    //local var ref to defQueue, so cannot just reassign the one\n                    //on context.\n                    apsp.apply(context.defQueue,\n                               [context.defQueue.length - 1, 0].concat(globalDefQueue));\n                    globalDefQueue = [];\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var args;\n\n                context.takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        break;\n                    } else if (args[0] === moduleName) {\n                        //Found matching require.def call for this script!\n                        break;\n                    } else {\n                        //Some other named require.def call, most likely the result\n                        //of a build layer that included many require.def calls.\n                        callDefMain(args);\n                        args = null;\n                    }\n                }\n                if (args) {\n                    callDefMain(args);\n                } else {\n                    //A script that does not call define(), so just simulate\n                    //the call for it. Special exception for jQuery dynamic load.\n                    callDefMain([moduleName, [],\n                                moduleName === \"jquery\" && typeof jQuery !== \"undefined\" ?\n                                function () {\n                                    return jQuery;\n                                } : null]);\n                }\n\n                //Mark the script as loaded. Note that this can be different from a\n                //moduleName that maps to a require.def call. This line is important\n                //for traditional browser scripts.\n                loaded[moduleName] = true;\n\n                //If a global jQuery is defined, check for it. Need to do it here\n                //instead of main() since stock jQuery does not register as\n                //a module via define.\n                jQueryCheck();\n\n                //Doing this scriptCount decrement branching because sync envs\n                //need to decrement after resume, otherwise it looks like\n                //loading is complete after the first dependency is fetched.\n                //For browsers, it works fine to decrement after, but it means\n                //the checkLoaded setTimeout 50 ms cost is taken. To avoid\n                //that cost, decrement beforehand.\n                if (req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n                resume();\n                if (!req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n            },\n\n            /**\n             * Converts a module name + .extension into an URL path.\n             * *Requires* the use of a module name. It does not support using\n             * plain URLs like nameToUrl.\n             */\n            toUrl: function (moduleNamePlusExt, relModuleMap) {\n                var index = moduleNamePlusExt.lastIndexOf(\".\"),\n                    ext = null;\n\n                if (index !== -1) {\n                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                }\n\n                return context.nameToUrl(moduleNamePlusExt, ext, relModuleMap);\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             */\n            nameToUrl: function (moduleName, ext, relModuleMap) {\n\n                var paths, packages, pkg, pkgPath, syms, i, parentModule, url,\n                    config = context.config;\n\n                if (moduleName.indexOf(\"./\") === 0 || moduleName.indexOf(\"../\") === 0) {\n                    //A relative ID, just map it relative to relModuleMap\'s url\n                    syms = relModuleMap && relModuleMap.url ? relModuleMap.url.split(\'/\') : [];\n                    //Pop off the file name.\n                    if (syms.length) {\n                        syms.pop();\n                    }\n                    syms = syms.concat(moduleName.split(\'/\'));\n                    trimDots(syms);\n                    url = syms.join(\'/\') +\n                          (ext ? ext :\n                          (req.jsExtRegExp.test(moduleName) ? \"\" : \".js\"));\n                } else {\n\n                    //Normalize module name if have a base relative module name to work from.\n                    moduleName = normalize(moduleName, relModuleMap);\n\n                    //If a colon is in the URL, it indicates a protocol is used and it is just\n                    //an URL to a file, or if it starts with a slash or ends with .js, it is just a plain file.\n                    //The slash is important for protocol-less URLs as well as full paths.\n                    if (req.jsExtRegExp.test(moduleName)) {\n                        //Just a plain path, not module name lookup, so just return it.\n                        //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                        //an extension, this method probably needs to be reworked.\n                        url = moduleName + (ext ? ext : \"\");\n                    } else {\n                        //A module that needs to be converted to a path.\n                        paths = config.paths;\n                        packages = config.packages;\n\n                        syms = moduleName.split(\"/\");\n                        //For each module name segment, see if there is a path\n                        //registered for it. Start with most specific name\n                        //and work up from it.\n                        for (i = syms.length; i > 0; i--) {\n                            parentModule = syms.slice(0, i).join(\"/\");\n                            if (paths[parentModule]) {\n                                syms.splice(0, i, paths[parentModule]);\n                                break;\n                            } else if ((pkg = packages[parentModule])) {\n                                //If module name is just the package name, then looking\n                                //for the main module.\n                                if (moduleName === pkg.name) {\n                                    pkgPath = pkg.location + \'/\' + pkg.main;\n                                } else {\n                                    pkgPath = pkg.location + \'/\' + pkg.lib;\n                                }\n                                syms.splice(0, i, pkgPath);\n                                break;\n                            }\n                        }\n\n                        //Join the path parts together, then figure out if baseUrl is needed.\n                        url = syms.join(\"/\") + (ext || \".js\");\n                        url = (url.charAt(0) === \'/\' || url.match(/^\\w+:/) ? \"\" : config.baseUrl) + url;\n                    }\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf(\'?\') === -1 ? \'?\' : \'&\') +\n                                         config.urlArgs) : url;\n            }\n        };\n\n        //Make these visible on the context so can be called at the very\n        //end of the file to bootstrap\n        context.jQueryCheck = jQueryCheck;\n        context.resume = resume;\n\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = require = function (deps, callback) {\n\n        //Find the right context, use default\n        var contextName = defContextName,\n            context, config;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== \"string\") {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = arguments[2];\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = contexts[contextName] ||\n                  (contexts[contextName] = newContext(contextName));\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback);\n    };\n\n    req.version = version;\n    req.isArray = isArray;\n    req.isFunction = isFunction;\n    req.mixin = mixin;\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    s = req.s = {\n        contexts: contexts,\n        //Stores a list of URLs that should not get async script tag treatment.\n        skipAsync: {},\n        isPageLoaded: !isBrowser,\n        readyCalls: []\n    };\n\n    req.isAsync = req.isBrowser = isBrowser;\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName(\"head\")[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName(\"base\")[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = function (err) {\n        throw err;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var contextName = context.contextName,\n            urlFetched = context.urlFetched,\n            loaded = context.loaded;\n        isDone = false;\n\n        //Only set loaded to false for tracking if it has not already been set.\n        if (!loaded[moduleName]) {\n            loaded[moduleName] = false;\n        }\n\n        if (!urlFetched[url]) {\n            context.scriptCount += 1;\n            req.attach(url, contextName, moduleName);\n            urlFetched[url] = true;\n\n            //If tracking a jQuery, then make sure its readyWait\n            //is incremented to prevent its ready callbacks from\n            //triggering too soon.\n            if (context.jQuery && !context.jQueryIncremented) {\n                context.jQuery.readyWait += 1;\n                context.jQueryIncremented = true;\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        var scripts, i, script;\n        if (interactiveScript && interactiveScript.readyState === \'interactive\') {\n            return interactiveScript;\n        }\n\n        scripts = document.getElementsByTagName(\'script\');\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            if (script.readyState === \'interactive\') {\n                return (interactiveScript = script);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument\'s\n     * name.\n     */\n    define = req.def = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous functions\n        if (typeof name !== \'string\') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!req.isArray(deps)) {\n            callback = deps;\n            deps = [];\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!name && !deps.length && req.isFunction(callback)) {\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, \"\")\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and such, so always add those as dependencies.\n                //This is a bit wasteful for RequireJS modules that do not need\n                //an exports or module object, but erring on side of safety.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = [\"require\", \"exports\", \"module\"].concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (!node) {\n                return req.onError(new Error(\"ERROR: No matching script interactive for \" + callback));\n            }\n            if (!name) {\n                name = node.getAttribute(\"data-requiremodule\");\n            }\n            context = contexts[node.getAttribute(\"data-requirecontext\")];\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n\n        return undefined;\n    };\n\n    /**\n     * Executes a module callack function. Broken out as a separate function\n     * solely to allow the build system to sequence the files in the built\n     * layer in the right sequence.\n     *\n     * @private\n     */\n    req.execCb = function (name, callback, args) {\n        return callback.apply(null, args);\n    };\n\n    /**\n     * callback for script loads, used to check status of loading.\n     *\n     * @param {Event} evt the event from the browser for the script\n     * that was loaded.\n     *\n     * @private\n     */\n    req.onScriptLoad = function (evt) {\n        //Using currentTarget instead of target for Firefox 2.0\'s sake. Not\n        //all old browsers will be supported, but this one was easy enough\n        //to support and still makes sense.\n        var node = evt.currentTarget || evt.srcElement, contextName, moduleName,\n            context;\n\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\n            //Reset interactive script so a script node is not held onto for\n            //to long.\n            interactiveScript = null;\n\n            //Pull out the name of the module and the context.\n            contextName = node.getAttribute(\"data-requirecontext\");\n            moduleName = node.getAttribute(\"data-requiremodule\");\n            context = contexts[contextName];\n\n            contexts[contextName].completeLoad(moduleName);\n\n            //Clean up script binding.\n            if (node.removeEventListener) {\n                node.removeEventListener(\"load\", req.onScriptLoad, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                node.detachEvent(\"onreadystatechange\", req.onScriptLoad);\n            }\n        }\n    };\n\n    /**\n     * Attaches the script represented by the URL to the current\n     * environment. Right now only supports browser loading,\n     * but can be redefined in other environments to do the right thing.\n     * @param {String} url the url of the script to attach.\n     * @param {String} contextName the name of the context that wants the script.\n     * @param {moduleName} the name of the module that is associated with the script.\n     * @param {Function} [callback] optional callback, defaults to require.onScriptLoad\n     * @param {String} [type] optional type, defaults to text/javascript\n     */\n    req.attach = function (url, contextName, moduleName, callback, type) {\n        var node, loaded, context;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            callback = callback || req.onScriptLoad;\n            node = document.createElement(\"script\");\n            node.type = type || \"text/javascript\";\n            node.charset = \"utf-8\";\n            //Use async so Gecko does not block on executing the script if something\n            //like a long-polling comet tag is being run first. Gecko likes\n            //to evaluate scripts in DOM order, even for dynamic scripts.\n            //It will fetch them async, but only evaluate the contents in DOM\n            //order, so a long-polling script tag can delay execution of scripts\n            //after it. But telling Gecko we expect async gets us the behavior\n            //we want -- execute it whenever it is finished downloading. Only\n            //Helps Firefox 3.6+\n            //Allow some URLs to not be fetched async. Mostly helps the order!\n            //plugin\n            node.async = !s.skipAsync[url];\n\n            node.setAttribute(\"data-requirecontext\", contextName);\n            node.setAttribute(\"data-requiremodule\", moduleName);\n\n            //Set up load listener.\n            if (node.addEventListener) {\n                node.addEventListener(\"load\", callback, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous require.def call to a name.\n                //However, IE reports the script as being in \"interactive\"\n                //readyState at the time of the require.def call.\n                useInteractive = true;\n                node.attachEvent(\"onreadystatechange\", callback);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous require.def\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n            return node;\n        } else if (isWebWorker) {\n            //In a web worker, use importScripts. This is not a very\n            //efficient use of importScripts, importScripts will block until\n            //its script is downloaded and evaluated. However, if web workers\n            //are in play, the expectation that a build has been done so that\n            //only one script needs to be loaded anyway. This may need to be\n            //reevaluated if other use cases become common.\n            context = contexts[contextName];\n            loaded = context.loaded;\n            loaded[moduleName] = false;\n\n            importScripts(url);\n\n            //Account for anonymous modules\n            context.completeLoad(moduleName);\n        }\n        return null;\n    };\n\n\n    //Determine what baseUrl should be if not already defined via a require config object\n    s.baseUrl = cfg.baseUrl;\n    if (isBrowser && (!s.baseUrl || !head)) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        scripts = document.getElementsByTagName(\"script\");\n        if (cfg.baseUrlMatch) {\n            rePkg = cfg.baseUrlMatch;\n        } else {\n            //>>includeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(requireplugins-|require-)?jquery[\\-\\d\\.]*(min)?\\.js(\\W|$)/i;\n            //>>includeEnd(\"jquery\");\n\n            //>>includeStart(\"dojoConvert\", pragmas.dojoConvert);\n            rePkg = /dojo\\.js(\\W|$)/i;\n            //>>includeEnd(\"dojoConvert\");\n\n            //>>excludeStart(\"dojoConvert\", pragmas.dojoConvert);\n\n            //>>excludeStart(\"jquery\", pragmas.jquery);\n            rePkg = /(allplugins-)?require\\.js(\\W|$)/i;\n            //>>excludeEnd(\"jquery\");\n\n            //>>excludeEnd(\"dojoConvert\");\n        }\n\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            //Set the \"head\" where we can append children by\n            //using the script\'s parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n\n            //Look for a data-main attribute to set main script for the page\n            //to load.\n            if (!dataMain && (dataMain = script.getAttribute(\'data-main\'))) {\n                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];\n\n                //Favor using data-main tag as the base URL instead of\n                //trying to pattern-match src values.\n                if (!cfg.baseUrl && (src = script.src)) {\n                    src = src.split(\'/\');\n                    src.pop();\n                    //Make sure current config gets the value.\n                    s.baseUrl = cfg.baseUrl = src.length ? src.join(\'/\') : \'./\';\n                }\n            }\n\n            //Using .src instead of getAttribute to get an absolute URL.\n            //While using a relative URL will be fine for script tags, other\n            //URLs used for text! resources that use XHR calls might benefit\n            //from an absolute URL.\n            if (!s.baseUrl && (src = script.src)) {\n                m = src.match(rePkg);\n                if (m) {\n                    s.baseUrl = src.substring(0, m.index);\n                    break;\n                }\n            }\n        }\n    }\n\n    //****** START page load functionality ****************\n    /**\n     * Sets the page as loaded and triggers check for all modules loaded.\n     */\n    req.pageLoaded = function () {\n        if (!s.isPageLoaded) {\n            s.isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            //Part of a fix for FF < 3.6 where readyState was not set to\n            //complete so libraries like jQuery that check for readyState\n            //after page load where not getting initialized correctly.\n            //Original approach suggested by Andrea Giammarchi:\n            //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n            //see other setReadyState reference for the rest of the fix.\n            if (setReadyState) {\n                document.readyState = \"complete\";\n            }\n\n            req.callReady();\n        }\n    };\n\n    //See if there is nothing waiting across contexts, and if not, trigger\n    //callReady.\n    req.checkReadyState = function () {\n        var contexts = s.contexts, prop;\n        for (prop in contexts) {\n            if (!(prop in empty)) {\n                if (contexts[prop].waitCount) {\n                    return;\n                }\n            }\n        }\n        s.isDone = true;\n        req.callReady();\n    };\n\n    /**\n     * Internal function that calls back any ready functions. If you are\n     * integrating RequireJS with another library without require.ready support,\n     * you can define this method to call your page ready code instead.\n     */\n    req.callReady = function () {\n        var callbacks = s.readyCalls, i, callback, contexts, context, prop;\n\n        if (s.isPageLoaded && s.isDone) {\n            if (callbacks.length) {\n                s.readyCalls = [];\n                for (i = 0; (callback = callbacks[i]); i++) {\n                    callback();\n                }\n            }\n\n            //If jQuery with readyWait is being tracked, updated its\n            //readyWait count.\n            contexts = s.contexts;\n            for (prop in contexts) {\n                if (!(prop in empty)) {\n                    context = contexts[prop];\n                    if (context.jQueryIncremented) {\n                        context.jQuery.readyWait -= 1;\n                        context.jQueryIncremented = false;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Registers functions to call when the page is loaded\n     */\n    req.ready = function (callback) {\n        if (s.isPageLoaded && s.isDone) {\n            callback();\n        } else {\n            s.readyCalls.push(callback);\n        }\n        return req;\n    };\n\n    if (isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", req.pageLoaded, false);\n            window.addEventListener(\"load\", req.pageLoaded, false);\n            //Part of FF < 3.6 readystate fix (see setReadyState refs for more info)\n            if (!document.readyState) {\n                setReadyState = true;\n                document.readyState = \"loading\";\n            }\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", req.pageLoaded);\n\n            //DOMContentLoaded approximation, as found by Diego Perini:\n            //http://javascript.nwbox.com/IEContentLoaded/\n            if (self === self.top) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        //From this ticket:\n                        //http://bugs.dojotoolkit.org/ticket/11106,\n                        //In IE HTML Application (HTA), such as in a selenium test,\n                        //javascript in the iframe can\'t see anything outside\n                        //of it, so self===self.top is true, but the iframe is\n                        //not the top window and doScroll will be available\n                        //before document.body is set. Test document.body\n                        //before trying the doScroll trick.\n                        if (document.body) {\n                            document.documentElement.doScroll(\"left\");\n                            req.pageLoaded();\n                        }\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. NOTE: does not work with Firefox before 3.6. To support\n        //those browsers, manually call require.pageLoaded().\n        if (document.readyState === \"complete\") {\n            req.pageLoaded();\n        }\n    }\n    //****** END page load functionality ****************\n\n    //Set up default context. If require was a configuration object, use that as base config.\n    req(cfg);\n\n    //If modules are built into require.js, then need to make sure dependencies are\n    //traced. Use a setTimeout in the browser world, to allow all the modules to register\n    //themselves. In a non-browser env, assume that modules are not built into require.js,\n    //which seems odd to do on the server.\n    if (typeof setTimeout !== \"undefined\") {\n        ctx = s.contexts[(cfg.context || defContextName)];\n        //Indicate that the script that includes require() is still loading,\n        //so that require()\'d dependencies are not traced until the end of the\n        //file is parsed (approximated via the setTimeout call).\n        ctx.requireWait = true;\n        setTimeout(function () {\n            ctx.requireWait = false;\n\n            //Any modules included with the require.js file will be in the\n            //global queue, assign them to this context.\n            ctx.takeGlobalQueue();\n\n            //Allow for jQuery to be loaded/already in the page, and if jQuery 1.4.3,\n            //make sure to hold onto it for readyWait triggering.\n            ctx.jQueryCheck();\n\n            if (!ctx.scriptCount) {\n                ctx.resume();\n            }\n            req.checkReadyState();\n        }, 0);\n    }\n}());\n\n/**\n * @license RequireJS i18n Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, navigator: false, define: false */\n\"use strict\";\n\n/**\n * This plugin handles i18n! prefixed modules. It does the following:\n *\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\n * module does not want to specify what locale to load. So it just specifies\n * the top-level bundle, like \"i18n!nls/colors\".\n *\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\n * bundle since it does not have a locale in its name. It will then try to find\n * the best match locale available in that master bundle, then request all the\n * locale pieces for that best match locale. For instance, if the locale is \"en-us\",\n * then the plugin will ask for the \"en-us\", \"en\" and \"root\" bundles to be loaded\n * (but only if they are specified on the master bundle).\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/colors bundle to be that mixed in locale.\n *\n * 2) A regular module specifies a specific locale to load. For instance,\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\n * since maybe only fr or just root is defined for that locale. Once that best\n * fit is found, all of its locale pieces need to have their bundles loaded.\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\n */\n(function () {\n    //regexp for reconstructing the master bundle name from parts of the regexp match\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\n    //so, if match[5] is blank, it means this is the top bundle definition.\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\n\n    //Helper function to avoid repeating code. Lots of arguments in the\n    //desire to stay functional and support RequireJS contexts without having\n    //to know about the RequireJS contexts.\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\n        if (master[locale]) {\n            needed.push(locale);\n            if (master[locale] === true || master[locale] === 1) {\n                toLoad.push(prefix + locale + \'/\' + suffix);\n            }\n        }\n    }\n\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\n        var fullName = prefix + locale + \'/\' + suffix;\n        if (require._fileExists(req.nameToUrl(fullName, null))) {\n            toLoad.push(fullName);\n        }\n    }\n\n    define(\"require/i18n\",{\n        /**\n         * Called when a dependency needs to be loaded.\n         */\n        load: function (name, req, onLoad, config) {\n            config = config || {};\n\n            var masterName,\n                match = nlsRegExp.exec(name),\n                prefix = match[1],\n                locale = match[4],\n                suffix = match[5],\n                parts = locale.split(\"-\"),\n                toLoad = [],\n                value = {},\n                i, part, current = \"\";\n\n            //If match[5] is blank, it means this is the top bundle definition,\n            //so it does not have to be handled. Locale-specific requests\n            //will have a match[4] value but no match[5]\n            if (match[5]) {\n                //locale-specific bundle\n                prefix = match[1];\n                masterName = prefix + suffix;\n            } else {\n                //Top-level bundle.\n                masterName = name;\n                suffix = match[4];\n                locale = config.locale || (config.locale =\n                        typeof navigator === \"undefined\" ? \"root\" :\n                        (navigator.language ||\n                         navigator.userLanguage || \"root\").toLowerCase());\n                parts = locale.split(\"-\");\n            }\n\n            if (config.isBuild) {\n                //Check for existence of all locale possible files and\n                //require them if exist.\n                toLoad.push(masterName);\n                addIfExists(req, \"root\", toLoad, prefix, suffix);\n                for (i = 0; (part = parts[i]); i++) {\n                    current += (current ? \"-\" : \"\") + part;\n                    addIfExists(req, current, toLoad, prefix, suffix);\n                }\n                req(toLoad);\n                onLoad();\n            } else {\n                //First, fetch the master bundle, it knows what locales are available.\n                req([masterName], function (master) {\n                    //Figure out the best fit\n                    var needed = [];\n\n                    //Always allow for root, then do the rest of the locale parts.\n                    addPart(\"root\", master, needed, toLoad, prefix, suffix);\n                    for (i = 0; (part = parts[i]); i++) {\n                        current += (current ? \"-\" : \"\") + part;\n                        addPart(current, master, needed, toLoad, prefix, suffix);\n                    }\n\n                    //Load all the parts missing.\n                    req(toLoad, function () {\n                        var i, partBundle;\n                        for (i = needed.length - 1; i > -1 && (part = needed[i]); i--) {\n                            partBundle = master[part];\n                            if (partBundle === true || partBundle === 1) {\n                                partBundle = req(prefix + part + \'/\' + suffix);\n                            }\n                            require.mixin(value, partBundle);\n                        }\n\n                        //All done, notify the loader.\n                        onLoad(value);\n                    });\n                });\n            }\n        }\n    });\n}());\n\n/**\n * @license RequireJS text Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint regexp: false, nomen: false, plusplus: false */\n/*global require: false, XMLHttpRequest: false, ActiveXObject: false,\n  define: false */\n\"use strict\";\n\n(function () {\n    var progIds = [\'Msxml2.XMLHTTP\', \'Microsoft.XMLHTTP\', \'Msxml2.XMLHTTP.4.0\'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\\'\\\"](\\d)*.(\\d)*[\\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        buildMap = [];\n\n    if (!require.textStrip) {\n        require.textStrip = function (text) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (text) {\n                text = text.replace(xmlRegExp, \"\");\n                var matches = text.match(bodyRegExp);\n                if (matches) {\n                    text = matches[1];\n                }\n            } else {\n                text = \"\";\n            }\n            return text;\n        };\n    }\n\n    if (!require.jsEscape) {\n        require.jsEscape = function (text) {\n            return text.replace(/([\'\\\\])/g, \'\\\\$1\')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\");\n        };\n    }\n\n    //Upgrade require to add some methods for XHR handling. But it could be that\n    //this require is used in a non-browser env, so detect for existing method\n    //before attaching one.\n    if (!require.getXhr) {\n        require.getXhr = function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else {\n                for (i = 0; i < 3; i++) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            if (!xhr) {\n                throw new Error(\"require.getXhr(): XMLHttpRequest not available\");\n            }\n\n            return xhr;\n        };\n    }\n\n    if (!require.fetchText) {\n        require.fetchText = function (url, callback) {\n            var xhr = require.getXhr();\n            xhr.open(\'GET\', url, true);\n            xhr.onreadystatechange = function (evt) {\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    callback(xhr.responseText);\n                }\n            };\n            xhr.send(null);\n        };\n    }\n\n    define(\"require/text\",{\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            var strip = false, url, index = name.indexOf(\".\"),\n                modName = name.substring(0, index),\n                ext = name.substring(index + 1, name.length);\n\n            index = ext.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = ext.substring(index + 1, ext.length);\n                strip = strip === \"strip\";\n                ext = ext.substring(0, index);\n            }\n\n            //Load the text.\n            url = req.nameToUrl(modName, \".\" + ext);\n            require.fetchText(url, function (text) {\n                text = strip ? require.textStrip(text) : text;\n                if (config.isBuild && config.inlineText) {\n                    buildMap[name] = text;\n                }\n                onLoad(text);\n            });\n        },\n\n        write: function (pluginName, moduleName, write) {\n            if (moduleName in buildMap) {\n                var text = require.jsEscape(buildMap[moduleName]);\n                write(\"define(\'\" + pluginName + \"!\" + moduleName  +\n                      \"\', function () { return \'\" + text + \"\';});\\n\");\n            }\n        }\n    });\n}());\n\n\n(function () {\n    /**\n * @license RequireJS Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\nvar logger = {\n\tTRACE: 0,\n\tINFO: 1,\n\tWARN: 2,\n\tERROR: 3,\n\tlevel: 0,\n\tlogPrefix: \"\",\n\n\ttrace: function(message){\n\t\tif(this.level <= this.TRACE){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\tinfo: function(message){\n\t\tif(this.level <= this.INFO){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\twarn: function(message){\n\t\tif(this.level <= this.WARN){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\terror: function(message){\n\t\tif(this.level <= this.ERROR){\n\t\t\tthis._print(message);\n\t\t}\n\t},\n\n\t_print: function(message){\n\t\tthis._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n\t},\n\n        _sysPrint: function(message){\n            print(message);\n        }\n}\n\n/**\n * @license RequireJS Copyright (c) 2010, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint plusplus: false, regexp: false */\n/*global Packages: false, logger: false, fileUtil: false */\n\"use strict\";\n\nvar commonJs = {\n    depRegExp: /require\\s*\\(\\s*[\"\']([\\w-_\\.\\/]+)[\"\']\\s*\\)/g,\n\n    //Set this to false in non-rhino environments. If rhino, then it uses\n    //rhino\'s decompiler to remove comments before looking for require() calls,\n    //otherwise, it will use a crude regexp approach to remove comments. The\n    //rhino way is more robust, but he regexp is more portable across environments.\n    useRhino: true,\n\n    //Set to false if you do not want this file to log. Useful in environments\n    //like node where you want the work to happen without noise.\n    useLog: true,\n\n    //Set to true to see full converted module contents logged to output.\n    logConverted: false,\n\n    convertDir: function (commonJsPath, savePath, prefix) {\n        //Normalize prefix\n        prefix = prefix ? prefix + \"/\" : \"\";\n\n        var fileList, i,\n            jsFileRegExp = /\\.js$/,\n            fileName, moduleName, convertedFileName, fileContents;\n\n        //Get list of files to convert.\n        fileList = fileUtil.getFilteredFileList(commonJsPath, /\\w/, true);\n\n        //Normalize on front slashes and make sure the paths do not end in a slash.\n        commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n        savePath = savePath.replace(/\\\\/g, \"/\");\n        if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n            commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n        }\n        if (savePath.charAt(savePath.length - 1) === \"/\") {\n            savePath = savePath.substring(0, savePath.length - 1);\n        }\n\n        //Cycle through all the JS files and convert them.\n        if (!fileList || !fileList.length) {\n            if (commonJsPath === \"convert\") {\n                //A request just to convert one file.\n                logger.trace(\'\\n\\n\' + commonJs.convert(savePath, fileUtil.readFile(savePath)));\n            } else {\n                logger.error(\"No files to convert in directory: \" + commonJsPath);\n            }\n        } else {\n            for (i = 0; (fileName = fileList[i]); i++) {\n                convertedFileName = fileName.replace(commonJsPath, savePath);\n\n                //Handle JS files.\n                if (jsFileRegExp.test(fileName)) {\n                    moduleName = fileName.replace(commonJsPath + \"/\", \"\").replace(/\\.js$/, \"\");\n\n                    fileContents = fileUtil.readFile(fileName);\n                    fileContents = commonJs.convert(prefix + moduleName, fileName, fileContents);\n                    fileUtil.saveUtf8File(convertedFileName, fileContents);\n                } else {\n                    //Just copy the file over.\n                    fileUtil.copyFile(fileName, convertedFileName, true);\n                }\n            }\n        }\n    },\n\n    /**\n     * Removes the comments from a string. Uses a more robust method if\n     * Rhino is available, otherwise a cruder regexp is used. If the regexp\n     * is used, then the contents may not be executable, but hopefully good\n     * enough to use to find require() calls.\n     *\n     * @param {String} fileContents\n     * @param {String} fileName mostly used for informative reasons if an error.\n     *\n     * @returns {String} a string of JS with comments removed.\n     */\n    removeComments: function (fileContents, fileName) {\n        var context, script;\n        if (commonJs.useRhino) {\n            context = Packages.org.mozilla.javascript.Context.enter();\n            script = context.compileString(fileContents, fileName, 1, null);\n            return String(context.decompileScript(script, 0));\n        } else {\n            return fileContents.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\");\n        }\n    },\n\n    /**\n     * Regexp for testing if there is already a require.def call in the file,\n     * in which case do not try to convert it.\n     */\n    defRegExp: /(require\\s*\\.\\s*def|define)\\s*\\(/,\n\n    /**\n     * Regexp for testing if there is a require([]) or require(function(){})\n     * call, indicating the file is already in requirejs syntax.\n     */\n    rjsRegExp: /require\\s*\\(\\s*(\\[|function)/,\n\n    /**\n     * Does the actual file conversion.\n     *\n     * @param {String} moduleName the name of the module to use for the\n     * define() call.\n     *\n     * @param {String} fileName the name of the file.\n     *\n     * @param {String} fileContents the contents of a file :)\n     *\n     * @param {Boolean} skipDeps if true, require(\"\") dependencies\n     * will not be searched, but the contents will just be wrapped in the\n     * standard require, exports, module dependencies. Only usable in sync\n     * environments like Node where the require(\"\") calls can be resolved on\n     * the fly.\n     *\n     * @returns {String} the converted contents\n     */\n    convert: function (moduleName, fileName, fileContents, skipDeps) {\n        //Strip out comments.\n        try {\n            var deps = [], depName, match,\n                //Remove comments\n                tempContents = commonJs.removeComments(fileContents, fileName),\n                baseName = moduleName.split(\"/\");\n\n            //First see if the module is not already RequireJS-formatted.\n            if (commonJs.defRegExp.test(tempContents) || commonJs.rjsRegExp.test(tempContents)) {\n                return fileContents;\n            }\n\n            //Set baseName to be one directory higher than moduleName.\n            baseName.pop();\n\n            //Reset the regexp to start at beginning of file. Do this\n            //since the regexp is reused across files.\n            commonJs.depRegExp.lastIndex = 0;\n\n            if (!skipDeps) {\n                //Find dependencies in the code that was not in comments.\n                while ((match = commonJs.depRegExp.exec(tempContents))) {\n                    depName = match[1];\n                    if (commonJs.useLog) {\n                        logger.trace(\"  \" + depName);\n                    }\n                    if (depName) {\n                        deps.push(\'\"\' + depName + \'\"\');\n                    }\n                }\n            }\n\n            //Construct the wrapper boilerplate.\n            fileContents = \'define([\"require\", \"exports\", \"module\"\' +\n                   (deps.length ? \', \' + deps.join(\",\") : \'\') + \'], \' +\n                   \'function(require, exports, module) {\\n\' +\n                   (commonJs.logConverted ? \'global._requirejs_logger.trace(\"Evaluating module: \' + moduleName + \'\");\\n\' : \"\") +\n                   fileContents +\n                   \'\\n});\\n\';\n        } catch (e) {\n            logger.error(\"COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n            return fileContents;\n        }\n\n        if (commonJs.logConverted) {\n            logger.trace(\"\\nREQUIREJS CONVERTED MODULE: \" + moduleName + \"\\n\\n\" + fileContents + \"\\n\");\n        }\n        return fileContents;\n    }\n};\n\n\n    var natives = process.binding(\'natives\'),\n        isDebug = global.__requireIsDebug,\n        paths = global.__requirePaths,\n        suffixRegExp = /\\.js$/,\n        extensions = [\'.js\', \'.node\', \'/index.js\', \'/index.node\'],\n        baseContext = require.s.contexts._,\n        noUrls = {\n            require: true,\n            exports: true,\n            module: true\n        };\n\n    function generateNodeExtension(context, url) {\n        var exports = {};\n\n        if (!context.nodeExts) {\n            context.nodeExts = {};\n        }\n        context.nodeExts[url] = exports;\n\n        process.dlopen(url, exports);\n\n        return \'define(function() { return require.s.contexts[\"\' +\n                context.contextName +\n                \'\"].nodeExts[\"\' +\n                url +\n                \'\"];});\';\n    }\n\n    require.paths = paths;\n\n    //Override require callback to use exports as the \"this\", to accomodate\n    //some modules that attach to \"this\". WTF? Specifically,\n    //socket.io/support/socket.io-client/lib/io.js.\n    require.execCb = function (name, cb, args) {\n        return cb.apply(baseContext.defined[name] || null, args);\n    };\n\n    require.get = function (context, moduleName, relModuleMap) {\n        if (moduleName === \"require\" || moduleName === \"exports\" || moduleName === \"module\") {\n            require.onError(new Error(\"Explicit require of \" + moduleName + \" is not allowed.\"));\n        }\n\n        var ret,\n            moduleMap = context.makeModuleMap(moduleName, relModuleMap);\n\n        //Normalize module name, if it contains . or ..\n        moduleName = moduleMap.fullName;\n\n        if (moduleName in context.defined) {\n            ret = context.defined[moduleName];\n        } else {\n            if (ret === undefined) {\n                //Try to dynamically fetch it.\n                require.load(context, moduleName, moduleMap.url);\n                //The above call is sync, so can do the next thing safely.\n                ret = context.defined[moduleName];\n            }\n        }\n\n        return ret;\n    };\n\n    function tryExtensions(url) {\n        var i, ext, tempUrl;\n        for (i = 0; (ext = extensions[i]); i++) {\n            tempUrl = url + ext;\n            if (require._fileExists(tempUrl)) {\n                return tempUrl;\n            }\n        }\n        return null;\n    }\n\n    require.toModuleUrl = function (context, moduleName, relModuleMap) {\n        //Do not bother for modules that will not have URLs.\n        if (noUrls[moduleName]) {\n            return null;\n        }\n\n        //Start with normal logic\n        var url = context.nameToUrl(moduleName, null, relModuleMap),\n            tempUrl, i, path;\n\n        //Now apply Node lookup logic.\n        //Look up source for the module. Use node rules to look for name.js,\n        //name.node, name/index.js, name/index.node, then look in node\n        //natives cache. Use the natives cache last, to allow for path mapping\n        //overrides to native, to allow monkey patching.\n        if (require._fileExists(url)) {\n            return url;\n        }\n\n        //Remove the .js extension.\n        url = url.replace(suffixRegExp, \'\');\n\n        //Try normal url extensions\n        if ((tempUrl = tryExtensions(url))) {\n            return tempUrl;\n        }\n\n        //Now try in require.paths, do this after doing RequireJS logic.\n        url = moduleName;\n        for (i = 0; i < paths.length; i++) {\n            path = paths[i];\n            if (path) {\n                if ((tempUrl = tryExtensions(path + \'/\' + url))) {\n                    return tempUrl;\n                }\n            }\n        }\n\n        //See if it is in the native list. Do this last to allow\n        //for monkey patch overrides.\n        if (natives[moduleName]) {\n            //a natives module that is burned into node.\n            return \"nodenative:\" + moduleName;\n        }\n\n        return null;\n    };\n\n    require.load = function (context, moduleName, url) {\n        var dirName, content;\n\n        //isDone is used by require.ready()\n        require.s.isDone = false;\n\n        if (!url) {\n            //Node seems to fail \"silently\" if it does not find a module\n            //for a given path. Was doing the \"cannot find module\" error\n            //but now just log it.\n            url = \"about:404\";\n            content = \" \";\n            if (isDebug) {\n                logger.trace(\">> RequireJS cannot find file for module: \" +\n                            moduleName + \", using an empty object.\");\n            }\n        } else if (isDebug) {\n            logger.trace(\"RequireJS loading module: \" + moduleName + \" at path: \" + url);\n        }\n\n        if (!content) {\n            if (url.indexOf(\'nodenative:\') === 0) {\n                content = natives[moduleName];\n            } else if (url.indexOf(\'.node\') === url.length - 5) {\n                content = generateNodeExtension(context, url);\n            } else {\n                content = require._nodeReadFile(url);\n            }\n        }\n\n        //Some node modules have a shell script path thing at the top, remove\n        content = content.replace(/^\\#\\!.*[\\r\\n]/, \'\');\n\n        //If a CommonJS module, translate it on the fly.\n        //The commonJs module is from build/jslib/commonJs.js\n        content = commonJs.convert(moduleName, url, content, true);\n\n        //TODO: remove when node code is updated:\n        //sys has an obsolete circular ref to child_process. Remove it.\n        if (moduleName === \"sys\") {\n            content = content.replace(/,\\s*\"child_process\"/, \"\");\n        }\n\n        //Attempt to support __dirname and __filename in node\n        dirName = url.split(\'/\');\n        dirName.pop();\n        if (dirName.length) {\n            dirName = dirName.join(\'/\');\n        } else {\n            dirName = \'.\';\n        }\n        content = \'(function () { var __dirname = \"\' + dirName +\n                  \'\"; var __filename = \"\' + url +\n                  \'\";\\n\' + content + \'\\n}());\';\n\n\n        //Indicate a the module is in process of loading.\n        context.loaded[moduleName] = false;\n        context.scriptCount += 1;\n\n        process.compile(content, url);\n\n        //Support anonymous modules.\n        context.completeLoad(moduleName);\n    };\n\n    //Adapter to get text plugin to work.\n    require.fetchText = function (url, callback) {\n        var content = require._nodeReadFile(url);\n        callback(content);\n    };\n\n    //Do some patch-ups\n    logger._sysPrint = global.__requireLog;\n    commonJs.useRhino = false;\n\n    //Set useLog to true if some modules do not seem to convert.\n    commonJs.useLog = false;\n    if (isDebug) {\n        commonJs.useLog = true;\n        //Uncomment to try to see converted module code, but seems to be\n        //not useful-- only prints a little bit, interferes with other output?\n        //commonJs.logConverted = true;\n        global._requirejs_logger = logger;\n    }\n\n    require._log = global.__requireLog;\n    require._nodeReadFile = global.__requireReadFile;\n    require._fileExists = global.__requireFileExists;\n\n    delete global.__requireReadFile;\n    delete global.__requireLog;\n    delete global.__requireIsDebug;\n    delete global.__requireFileExists;\n    delete global.__requirePaths;\n}());\n", "requirejs/requireAdapter.js");

    //Set the baseUrl to be the app directory, and pass in the paths.
    process.compile("require({baseUrl: '" + appDir + "'});", "baseUrl");

    //Showtime!
    //Try to support __dirname and __filename for node.
    content = 'var __filename = "' + appFilePath +
              '"; var __dirname = "' + appDir + '";\n' +
              fs.readFileSync(appFilePath);
    process.compile(content, appFilePath);
}());