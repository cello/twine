/**
 * @license Copyright (c) 2011 Cello Software, LLC.
 * All rights reserved.
 * Available via the new BSD License.
 */
/*jshint
	bitwise: false, curly: true, eqeqeq: true, forin: true, immed: true, indent: 4, maxlen: 100,
	newcap: true, noarg: true, noempty: true, onevar: true, passfail: false, undef: true,
	white: true
*/
/*global define: false, require: false */

define([
	'compose',
	'events',
	'promise',
	'lang',
	'array'
], function (compose, events, promise, lang, array) {
	return compose(
		compose,
		events.Evented,
		function Model() {
			this._commissions = [];
			this._decommissions = [];

			this.deps = this.deps || {};
			this.mixin = this.mixin || {};

			// if no id was provided
			if (!this.id) {
				// use the combination of service and name
				this.id = [this.service, this.name].join('/');
			}

			if (!this.module) {
				this.module = this.id;
			}
		}, {
			// id must be unique per registry
			id: '',

			// name must be unique per service
			name: '',
			// the combination of service and name must be unique per registry
			service: '',

			// module is what will be used to generate instances and can be either a string or an
			// object or a function.
			//	- a string will be used as a module id for require to load.
			//	- an object will be used as an instance and construct always returns that object
			//	- a function will be used as a constructor.  construct returns new instances
			module: null,

			// mixed into an instance generated by this model before it's constructor is called
			mixin: null,

			// this is a map of dependencies to be resolved before creating an instance.
			// the objects resolved based on these deps are then mixed into an instance.
			// property name -> a model spec as used by registry.getModel(model.deps[key])
			deps: null,

			// returns a promise to resolve a component
			resolve: function (args) {
				var model = this;

				// resolving might be asynchronous
				return promise.when(this.lifecycle.resolve(args), function (component) {
					model.emit('componentResolved', component);
					return component;
				});
			},

			// releases the component
			release: function (instance) {
				// releasing must be synchronous
				this.lifecycle.release(instance);
				this.emit('componentReleased', instance);
			},

			addMixin: function (obj) {
				compose.call(this.mixin, obj);
			},

			// returns a promise to build an instance based on this model
			construct: function (args) {
				var model = this;

				return this._getModule().then(function (module) {
					var specs = model.deps,
						registry = model.kernel.modelRegistry,
						deps = {};

					// if the module is a function then we resolve it as a constructor
					if (lang.isFunction(module)) {
						// get the models for all the specified dependencies
						array.forEach(lang.keys(specs), function (key) {
							deps[key] = registry.getModel(specs[key]).resolve();
						});

						// resolve all the dependencies and then construct an instance
						return promise.allKeys(deps).then(function (deps) {
							var inst = compose.create(compose, module, deps, model.mixin, args);
							return promise.seq(model._commissions, inst).then(function (instance) {
								model.emit('componentConstructed', instance);
								return instance;
							});
						});
					}

					// if the module is anything other than a function, return it as the instance
					model.emit('componentConstructed', module);
					return module;
				});
			},

			_getModule: function () {
				var dfd = promise.defer(),
					model = this;

				// if module is a string, it needs to be loaded
				// XXX: should there be a way to define a module that really is a string?
				if (lang.isString(model.module)) {
					require([model.module], function (module) {
						model.module = module;
						dfd.resolve(module);
					});
				}
				else {
					dfd.resolve(model.module);
				}

				return dfd.promise;
			},

			deconstruct: function (instance) {
				var model = this;

				return promise.seq(model._decommissions, instance).then(function (instance) {
					model.emit('componentDeconstructed', instance);
					return instance;
				});
			},

			addCommissioner: function (commissioner) {
				// a commissioner can provide 'commission' and/or 'decomission' help
				var commission = commissioner.commission,
					decommission = commissioner.decommission;

				if (lang.isFunction(commission)) {
					this._commissions.push(function () {
						return commission.apply(commissioner, arguments);
					});
				}

				if (lang.isFunction(decommission)) {
					this._decommissions.push(function () {
						return decommission.apply(commissioner, arguments);
					});
				}
			},

			destroy: function () {
				this.lifecycle.destroy();
			}
		}
	);
});
